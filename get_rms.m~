function rms = get_rms(step, num_stages, X, h, equal_mse)
    % mse is a boolean - true if using mse, false if const. step size
    % across layers
    
    if equal_mse
        ratios = get_equal_mse_ratios(num_stages, X);
    else
        ratios = ones(num_stages);
    end
    
    % fetch sub-images up to 4 level
    [x1,x2,x3,x4,y0,y1,y2,y3] = pyenc(X,h);
    
    % if statements ensure index does not exceed size of ratios array
    
    stepA = step;
    if num_stage >= 2
        stepB = step*ratios(2);
    else
        stepB = 0;
      
    if num_stage >= 3
        stepC = step*ratios(3);
    else
        stepC = 0;
        
    if num_stages >= 4
        stepD = step*ratios(4);
    else
        stepD = 0; 
    
    % quantise with different steps for each layer 
    X_discrete = quantise(X, step); % it IS right of me to use step here instead of step_X
    x1 = quantise(x1, stepA);
    x2 = quantise(x2, stepB);
    x3 = quantise(x3, stepC);
    x4 = quantise(x4, stepD);
    y0 = quantise(y0, stepA);
    y1 = quantise(y1, stepB);
    y2 = quantise(y2, stepC);
    y3 = quantise(y3, stepD);

    switch num_stages
        case 0
            rms = std(X(:) - X_discrete(:)); 
        case 1
            out1 = py1dec(x1,y0,h);
            rms = std(X(:) - out1(:));
        case 2
            out2 = py2dec(x2,y1,y0,h);
            rms = std(X(:) - out2(:)); 
        case 3
            out3 = py3dec(x3,y0,y1,y2,h);
            rms = std(X(:) - out3(:)); 
        case 4
            out4 = py4dec(x4,y0,y1,y2,y3,h);
            rms = std(X(:) - out4(:));
        otherwise
    end 
            
return 